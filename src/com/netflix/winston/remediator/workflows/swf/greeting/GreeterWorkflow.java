package com.netflix.winston.remediator.workflows.swf.greeting;

import com.amazonaws.services.simpleworkflow.flow.core.Promise;
import com.netflix.skynet.remediator.workflows.swf.greeting.GreeterActivitiesClient;
import com.netflix.skynet.remediator.workflows.swf.greeting.GreeterActivitiesClientImpl;


public class GreeterWorkflow implements IGreeterWorkflow {

	/*
	 * proxy to SWF to invoke activity tasks.  This proxy allows us to:
	 * - run the activity task in a different process than Skynet.
	 * - run the activity task asynchronously
	 * - manage an activity task input and return values.
	 *
	 * This proxy will be generated by the AWS Flow Framework base on @IGreetingActivity.  The generated classes will be prefix with "Cleint" and "ClientImpl" to the interface
	 * name (IGreetActivity).  
	 *
	 */
	private GreeterActivitiesClient activity = new GreeterActivitiesClientImpl();
	
	@Override
	public void greet() {
		
		/*
		 * Information derive from http://docs.aws.amazon.com/amazonswf/latest/awsflowguide/getting-started-example-helloworldworkflow.html
		 * 
		 * Each activity task is executed by SWF asynchronous (i.e. it immediately returns once SWF enqueus the activity task).
		 * The return Promise<T> is initially in an "unready state", which indicates the the object does not yet represent a valid return value.  When the
		 * corresponding activity task completes and returns, SWF asigns the return value to the Promise<T> object nad puts it in a "ready state".
		 * 
		 * Primary purpose of Promise>T? object is to manafge data flow between asynchronous components and control when they execute.  When you invoke an activity task,
		 * it immediately returns but the framework defers executing the corresponding activity method until any input Promise<T> objects are ready and represent valid data. 
		 */
		
	     Promise<String> name = activity.getName(); 
	     
	     /*
	      * @param name - SWF will not begin executing of this activity task until Promise<name> is in a "ready state".  This is a clever way of implementing a syncrhonous, linear workflow
	      * topology.
	      */
	     Promise<String> greeting = activity.getGreeting(name);
	     
	     /*
	      * @return Void - even though this activity task does not return any value, use Void to determine when SWF has completed the task.  Promise<Void> will initially
	      * be in an "unready state", after task completes, SWF will set it to "ready state".
	      */
	     Promise<Void> activity.say(greeting);
	}	
	
}
